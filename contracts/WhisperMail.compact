pragma language_version 0.20;
import CompactStandardLibrary;

export struct InboxKey {
    handle: Bytes<32>;
    index: Field;
}

// Map: handle_hash -> message_count
export ledger message_counts: Map<Bytes<32>, Field>;

// Map: hash(recipient, index) -> IPFS CID
export ledger inbox_entries: Map<Bytes<32>, Bytes<64>>;

witness get_sender_secret_key(): Bytes<32>;

export circuit send_message(
    sender_handle_hash: Bytes<32>,
    recipient_handle_hash: Bytes<32>,
    message_cid: Bytes<64>,
    sender_ownership_commitment: Bytes<32>
): [] {
    // 1. Verify sender ownership
    assert(disclose(sender_ownership_commitment) == persistentHash<Bytes<32>>(get_sender_secret_key()), "Invalid sender ownership proof");

    // 2. Get current count
    // Note: lookup returns 0 if not found, which is perfect for index 0
    const current_index = message_counts.lookup(disclose(recipient_handle_hash));

    // 3. Derive storage key
    const key_struct = InboxKey { 
        handle: disclose(recipient_handle_hash), 
        index: current_index 
    };
    const storage_key = persistentHash<InboxKey>(key_struct);

    // 4. Insert message
    inbox_entries.insert(storage_key, disclose(message_cid));

    // 5. Increment count
    message_counts.insert(
        disclose(recipient_handle_hash), 
        current_index + 1
    );
}

export circuit get_message_count(handle_hash: Bytes<32>): Field {
    return message_counts.lookup(disclose(handle_hash));
}

export circuit get_message_cid(handle_hash: Bytes<32>, index: Field): Bytes<64> {
    const key_struct = InboxKey { 
        handle: disclose(handle_hash), 
        index: disclose(index)
    };
    return inbox_entries.lookup(persistentHash<InboxKey>(key_struct));
}
