// Whisper Network - Identity & Email Verification
// Built for Midnight Network using Compact Language

contract WhisperRegistry {

    // Persistent State (Private Ledger)
    ledger {
        // Map of Email Commitment -> Verification Status
        // Commitment = Poseidon(secret_key)
        field verified_identities<Field, Boolean>;

        // Map of Handle -> Commitment
        field handles<String, Field>;
    }

    // Constructor
    constructor() {
        // Initialize state (implicitly done by map defaults)
    }

    // Circuit: Prove email ownership without revealing email
    // This runs inside the ZK Proof Server (local)
    circuit verify_email_ownership(
        secret_key: Field,
        public_commitment: Field
    ): Boolean {
        // In Compact, this generates a ZK constraint
        // Ensure the provided secret matches the public commitment
        return hash(secret_key) == public_commitment;
    }

    // Transition: Register Identity
    // Publicly updates the ledger if the ZK proof is valid
    export message register_identity(
        secret_key: Field,
        handle: String
    ) {
        // Generate commitment locally
        const commitment = hash(secret_key);

        // Verify ZK circuit constraints
        // This ensures the caller knows the secret for this commitment
        verify(verify_email_ownership(secret_key, commitment));

        // Update Ledger State
        // Check if identity already exists
        verify(!verified_identities[commitment]);
        // Check if handle is taken
        verify(!handles.member(handle));

        // Write to ledger
        verified_identities[commitment] = true;
        handles[handle] = commitment;
    }

    // Getter: Check if handle is available (Public View)
    export query is_handle_available(handle: String): Boolean {
        return !handles.member(handle);
    }
}
